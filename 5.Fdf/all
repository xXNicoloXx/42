
#include "fdf.h"
#include "mlx.h"

void ft_color(int nbr, t_map *m)
{
    int tmp;

    tmp = nbr/1048576;
    nbr = nbr - 1048576 * tmp;
    m->img.r = tmp * 16;
    tmp = nbr/65536;
    nbr = nbr - 65536 * tmp;
    m->img.r += tmp;
    tmp = nbr/4096;
    nbr = nbr - 4096 * tmp;
    m->img.g = tmp * 16;
    tmp = nbr/256;
    nbr = nbr - 256 * tmp;
    m->img.g += tmp;
    tmp = nbr/16;
    nbr = nbr - 16 * tmp;
    m->img.b = tmp * 16;
    m->img.b += nbr;
}

void ft_draw(t_map *m, float x, float y, int color)
{
    unsigned long pixel;
	x = roundf(x);
	y = roundf(y);
    ft_color(color, m);
    pixel = (y * m->img.size) + (x * 4);
	if ((m->img.size) * m->winy < pixel - 5 || x <= 0 || y <= 0 || y > m->y * m->winy || x > m->winx)
		return ;
	
    if (m->img.e == 1)        // Most significant (Alpha) byte first
    {
        m->img.data[pixel + 0] = 0;
        m->img.data[pixel + 1] = m->img.r;
        m->img.data[pixel + 2] = m->img.g;
        m->img.data[pixel + 3] = m->img.b;
    }
    else if (m->img.e == 0)   // Least significant (Blue) byte first
    {
        m->img.data[pixel + 0] = m->img.b;
        m->img.data[pixel + 1] = m->img.g;
        m->img.data[pixel + 2] = m->img.r;
        m->img.data[pixel + 3] = 0;
    }
}

void ft_tab_deg(t_map *m, int start, int end)
{
	int i;
	float pc;
	float diff;
	t_map c;
	
	ft_color(m->color[start], m);
	ft_color(m->color[end], &c);
	diff = end - start - 1;
	i = 0 ;
	while (i <= diff)
	{
		pc = ((i)/diff);
		m->color[start + i] = roundf((m->img.r*(1-pc)) + (c.img.r*pc))* 65536 + roundf((m->img.g*(1-pc)) + (c.img.g*pc)) * 256 + roundf((m->img.b*(1-pc)) + (c.img.b*pc));

		i++;
	}
}

void ft_tab_color(t_map *m)
{
	int i;
	int j;
	
	i = 0;
	while (i < 100)
	{
		if (m->color[i] != 0)
		{
			j = i;
			i++;		
			while (m->color[i] == 0 && i < 100)
				i++;
			if (99 < i)
				return ;
			ft_tab_deg(m, j, i);				
		}
		else
			i++;
	}

}


void ft_init_color(t_map *m)
{
	int i;

	i = 0;
	while(i < 100)
	{
		m->color[i] = 0;
		i++;
	}
	m->color[0] = 0x000020;
	m->color[5] = 0x0040ff;
	m->color[55] = 0x0090ff;
	m->color[61] = 0x0090ff;
	m->color[63] = 0x72CC00;
	m->color[73] = 0x298000;			//worldmap
	m->color[85] = 0x4f3000;
	m->color[87] = 0x4f3000;
	m->color[90] = 0xffffff;
	m->color[99] = 0xffffff;
	ft_tab_color(m);

}


#include "libft.h"

int	ft_atoi(const char *str)
{
	int	i;
	int	signe;
	int	nb;

	signe = 1;
	i = 0;
	nb = 0;
	while (('\t' <= str[i] && str[i] <= '\r') || (str[i] == ' '))
	{
		i++;
	}
	if (str[i] == '+')
		i++;
	else if (str[i] == '-')
	{
		i++;
		signe = -signe;
	}
	while ('0' <= str[i] && str[i] <= '9')
	{
		nb = nb * 10 + str[i] - 48;
		i++;
	}
	return (nb * signe);
}


#include "libft.h"

void	*ft_calloc(size_t nbitems, size_t size)
{
	size_t	count;
	size_t	tmax;
	char	*str;

	tmax = (size_t) -1;
	if (size != 0 && nbitems > (tmax / size))
		return (NULL);
	count = nbitems * size;
	str = malloc(nbitems * size);
	if (str == NULL)
		return (NULL);
	else
	{
		while (count)
		{
			str[count - 1] = '\0';
			count--;
		}
	}
	return (str);
}



#include "libft.h"

int	ft_isdigit(int str)
{	
	if (!((47 < str && str < 58)))
		return (0);
	return (1);
}

#include "libft.h"

static char	*ft_nbr_to_str(char *str, int n, int signe, int size)
{
	int	i;

	i = 0;
	if (signe == -1)
	{
		str[i++] = '-';
	}
	while (n > 0)
	{
		str[size] = n % 10 + 48;
		n = n / 10;
		size--;
	}
	return (str);
}

static	char	*ft_itoa_zero(void)
{
	char	*str;

	str = malloc(sizeof(char) * 2);
	if (str == NULL)
		return (NULL);
	str[0] = '0';
	str[1] = '\0';
	return (str);
}

static char	*ft_min_int(int n)
{
	char	*str;

	if (n == 0)
		return (ft_itoa_zero());
	str = malloc(sizeof(char) * 12);
	if (str == NULL)
		return (NULL);
	str[0] = '-';
	str[1] = '2';
	str[2] = '1';
	str[3] = '4';
	str[4] = '7';
	str[5] = '4';
	str[6] = '8';
	str[7] = '3';
	str[8] = '6';
	str[9] = '4';
	str[10] = '8';
	str[11] = '\0';
	return (str);
}

char	*ft_itoa(int n)
{
	char	*nbr;
	int		signe;
	int		size;
	int		ndb;

	signe = 1;
	size = 0;
	if (n == -2147483648 || n == 0)
		return (ft_min_int(n));
	if (n < 0)
	{
		signe = -1;
		size = 1;
		n = -n ;
	}
	ndb = n;
	while (n > 0)
	{
		n = n / 10;
		size++;
	}
	nbr = malloc(sizeof(char) * (size + 1));
	nbr[size] = '\0';
	return (ft_nbr_to_str(nbr, ndb, signe, --size));
}



#include "get_next_line.h"

char	*ft_dup_upligne(char *upligne, char *buffer, int i, int j)
{
	int	size;

	size = ft_s(&buffer[i], 1);
	while (--size + 1)
	{
		upligne[j] = buffer[i];
		buffer[i] = -42;
		i++;
		j++;
	}
	i = 0;
	while (upligne[i] != '\0')
	{
		if (upligne[i] == -42)
			upligne[i] = '\0';
		i++;
	}
	return (upligne);
}

#include "get_next_line.h"

int	ft_s(char *str, int verif)
{
	int	i;

	i = 0;
	while (str[i] != '\0' && str[i] != '\n')
		i++;
	if (str[i] == '\n' && verif == 1)
		i++;
	return (i);
}

char	*ft_my_malloc(char *buffer, char *ligne, int size)
{
	int		i;
	int		j;
	char	*upligne;

	i = 0;
	j = 0;
	if (buffer[i] == '\0')
		return (ligne);
	while (buffer[i] == -42)
		i++;
	upligne = malloc(sizeof(char) * (ft_s(ligne, 1) + ft_s(&buffer[i], 1) + 2));
	if (upligne == NULL)
		return (NULL);
	upligne[ft_s(ligne, 1) + ft_s(&buffer[i], 1)] = '\0';
	size = ft_s(ligne, 1);
	while (--size + 1)
	{
		upligne[j] = ligne[j];
		j++;
	}
	upligne = ft_dup_upligne(upligne, buffer, i, j);
	free(ligne);
	return (upligne);
}

char	*ft_new_line(char *buffer, int size, int fd)
{	
	char	*ligne;

	ligne = malloc(sizeof(char));
	if (ligne == NULL)
		return (NULL);
	ligne[0] = '\0';
	while (size != 0)
	{
		ligne = ft_my_malloc(buffer, ligne, size);
		if (ligne == NULL)
			return (free(ligne), NULL);
		if (ligne[ft_s(ligne, 0)] == '\n')
			return (ligne);
		size = read(fd, buffer, BUFFER_SIZE);
	}
	if (ligne[0] == '\0')
	{
		free(ligne);
		return (NULL);
	}
	return (ligne);
}

char	*get_next_line(int fd)
{
	int			size;
	static char	buffer[BUFFER_SIZE + 1] = {0};

	size = -5;
	buffer[BUFFER_SIZE] = '\0';
	if (buffer[0] == '\0')
		size = read(fd, buffer, BUFFER_SIZE);
	if (size == 0 || size == -1)
		return (NULL);
	return (ft_new_line(buffer, size, fd));
}



#include "mlx.h"
#include <math.h>
#include "fdf.h"

int ft_color_line(float nbpix, float pospix, t_map *m)
{
	float tmp;
	float deltah;
	if (m->lenline < 0)
		m->lenline *= -1;

	
	deltah = (float)m->maxh - (float)m->minh;
	if (m->hcolor1 < m->hcolor2)
	{
		if (nbpix < 0)
			nbpix *= -1;
		if (pospix < 0)
			pospix *= -1;
		tmp = (((100*(m->hcolor2 - m->minh)/deltah) - (100*(m->hcolor1 - m->minh)/deltah))/nbpix);
		return (m->color[(int)((100*(m->hcolor1 - m->minh)/deltah) + tmp * pospix)]);
	}
	else if (m->hcolor1 > m->hcolor2)
	{
		tmp = (((100*(m->hcolor1 - m->minh)/deltah) - (100*(m->hcolor2 - m->minh)/deltah))/nbpix);
		return (m->color[(int)((100*(m->hcolor1 - m->minh)/deltah) - tmp * pospix)]);
	}
	else 
	{
		tmp = (100*(m->hcolor2 - m->minh)/deltah);
		if (tmp == 100)
			tmp -= 1;
		return(m->color[(int)tmp]);
	}
		
	return (0x101010);
}

void ft_ligne(float ax, float ay, float bx, float by, t_map *m)
{
	float dx;
	int reverse;
	float dy;
	float unity;
	float i;
	float tmp;
	if ((ax < 0 || ay < 0 || ax > m->winx || ay > m->winy) && (bx < 0 || by < 0 || bx > m->winx || by > m->winy))
		return ;
	reverse = 0;
	if (bx < ax)
	{
		tmp = bx;
		bx = ax;
		ax = tmp;
		tmp = by;
		by = ay;
		ay = tmp;
		reverse = 1;

	}
	
	
	dx = (float)bx - (float)ax;
	dy = (float)by - (float)ay;
	unity = dy / dx;
	i = 0;
	if (dy == 0)
	{
		if (reverse == 1)
		{
			tmp = m->hcolor1;
			m->hcolor1 = m->hcolor2;
			m->hcolor2 = tmp;
		}
		while (i++ < dx)
		{
			ft_draw(m, ax, ay, ft_color_line(dx, i, m));
			ay = ay + unity;
			ax++;
		}
		return ;
	}
	else if ((0 < unity && unity < 1))
	{
		if (reverse == 1)
		{
			tmp = m->hcolor1;
			m->hcolor1 = m->hcolor2;
			m->hcolor2 = tmp;
		}
		while (i++ < dx)
		{
			ft_draw(m, ax, ay, ft_color_line(dx, i, m));
			ay = ay + unity;
			ax++;
		}
		return ;
	}
	else if (-1 <= unity && unity < 0)
	{
		if (reverse == 1)
		{
			tmp = m->hcolor1;
			m->hcolor1 = m->hcolor2;
			m->hcolor2 = tmp;
		}
		while (i++ < dx)
		{
			ft_draw(m, ax, ay, ft_color_line(dx, i, m));
			ay = ay + unity;
			ax++;
		}
		return ;
	}
	else if (1 <= unity)
	{
		if (reverse == 1)
		{
			tmp = m->hcolor1;
			m->hcolor1 = m->hcolor2;
			m->hcolor2 = tmp;
		}
		while (i < dy)
		{
			ft_draw(m, ax, ay, ft_color_line(dy, i, m));
			ay++;
			ax = ax + (1 / unity);
			i++;
		}
		return ;
	}
	else
	{
		if (reverse == 1)
		{			
			tmp = m->hcolor1;
			m->hcolor1 = m->hcolor2;
			m->hcolor2 = tmp;
		}
		while (i> dy)
		{
			ft_draw(m, ax, ay, ft_color_line(dy, i, m));
			ay--;
			ax = ax - (1 / unity);
			i--;
		}
	}
}

#include "mlx.h"
#include "fdf.h"
#include <X11/X.h>

int ft_monitoring(t_map *m)
{
    int i;
    int j;

    i = 0;
    j = 0;
    if (m->y == 0 && m->x == 0)
	{
		printf("pas bon");
		mlx_string_put(m->mlx,  m->mlx_win, m->winx/2-100, m->winy/2, 0xffffff, "Error invalid map");
	}
    else
    {
    while (i < 95)
    {
        while (j < 50)
        {
            mlx_pixel_put(m->mlx, m->mlx_win, j,  i, 0x404040);
            j++;
        }
        j = 0;
        i++;
    }
	mlx_string_put(m->mlx,  m->mlx_win, 5, 13, 0xffffff, "x: ");
    mlx_string_put(m->mlx,  m->mlx_win, 20, 13, 0xffffff, ft_itoa(m->x));
    mlx_string_put(m->mlx,  m->mlx_win, 5, 13*2, 0xffffff, "z: ");
    mlx_string_put(m->mlx,  m->mlx_win, 20, 13*2, 0xffffff, ft_itoa(m->y));
    mlx_string_put(m->mlx,  m->mlx_win, 5, 13*3, 0xffffff, "h: ");
    mlx_string_put(m->mlx,  m->mlx_win, 20, 13*3, 0xffffff, ft_itoa(m->minh));
    mlx_string_put(m->mlx,  m->mlx_win, 5, 13*4, 0xffffff, "H: ");
    mlx_string_put(m->mlx,  m->mlx_win, 20, 13*4, 0xffffff, ft_itoa(m->maxh));
    mlx_string_put(m->mlx,  m->mlx_win, 5, 13 *5, 0xffffff, "R:");
    mlx_string_put(m->mlx,  m->mlx_win, 20, 13 *5, 0xffffff, ft_itoa(m->r));
    mlx_string_put(m->mlx,  m->mlx_win, 5, 13*6, 0xffffff, "I: ");
    mlx_string_put(m->mlx,  m->mlx_win, 20, 13*6, 0xffffff, ft_itoa(m->i));
    mlx_string_put(m->mlx,  m->mlx_win, 5, 13*7, 0xffffff, "Z: ");
    mlx_string_put(m->mlx,  m->mlx_win, 20, 13*7, 0xffffff, ft_itoa(m->z));}
}